= Mature Modular Meta-framework (mmm)

image:https://raw.github.com/m-m-m/mmm/master/src/site/resources/images/logo.png[logo]

*Welcome to the wonderful world of http://m-m-m.sourceforge.net/index.html[mmm]*

== mmm-security

image:https://travis-ci.org/m-m-m/security.svg?branch=master["build-status",link="https://travis-ci.org/m-m-m/security"]

`mmm-security-crypt` is a library for simple and more secure usage of cryptography. https://en.wikipedia.org/wiki/Java_Cryptography_Architecture[JCA] and https://en.wikipedia.org/wiki/Java_Cryptography_Extension[JCE] offer an extensible API to provide cryptographic algorithms for Java. However, this API is very low-level what often leads to programming mistakes and severe security frauds (missing parameters like nonce). Further, you need a lot of knowledge of the underlying security algorithms or you will end up with runtime errors. Also, changing things often requires refactorings of the code using the encryption or signature algorithms. Finally, the JCA and JCE are limited and for many things you need extensions like http://bouncycastle.net/[BouncyCastle]. In some cases you need to create some security objects via BouncyCastle and others via the default provider and combine them properly to make things work. Again this opens pitfalls and requires a lot of knowledge.

This library allows you to get around all these problems and write your security related code more safe and easy. In this context when we are 
talking about security we mean aspects like:

* hashing
* encryption and decryption
* signing and verifying signatures
* key creation and management
* certificate creation and management
* key store management

Other aspects of security such as authentication, authorization, intrusion detection, attack prevention, etc. are not covered here.

=== Features

* Simple API to access and create cryptographic objects and algorithms.
* API enforces all parameters required for secure usage.
* Detailed JavaDocs assist you to make the correct choice.
* Flexible composition of algorithms: combine any hash (e.g. 5 x SHA-256) with any signature algorithm (e.g. ECIES) to create and verify signatures.
* Build in support to encrypt and decrypt binary streams on the fly with just one line of code.
* Usable and extendable also for cryptographic algorithms not already considered in the current release (if Java or BouncyCastle ships with a new algorithm you can use it by creating your own config without the need to wait for an update of this library).
* Extended support for like http://bouncycastle.org/[bouncycastle].
* Can be used with any other custom security provider.

=== Example
Here is an example for asymmetric encryption with `mmm-security-bc`:
[source,java]
-----
String hashAlgorithm = SecurityAlgorithmSha2.ALGORITHM_SHA_256; // "SHA-256";
SecurityHashConfig sha256x2 = new SecurityHashConfig(hashAlgorithm, 2);
SecurityAccessSecp256k1 access = SecurityAccessSecp256k1.ofPlain(sha256x2);
SecurityAsymmetricKeyCreator keyCreator = access.newKeyCreator();
SecurityAsymmetricKeyPair keyPair = keyCreator.generateKeyPair();
PublicKey publicKey = keyPair.getPublicKey();
PrivateKey privateKey = keyPair.getPrivateKey();
// encryption + decryption
byte[] rawMessage = "Secret message".getBytes(StandardCharsets.UTF_8);
SecurityEncryptor encryptor = access.newEncryptorUnsafe(publicKey);
byte[] encryptedMessage = encryptor.crypt(rawMessage, true);
SecurityDecryptor decryptor = access.newDecryptorUnsafe(privateKey);
byte[] decryptedMessage = decryptor.crypt(encryptedMessage, true);
assertThat(decryptedMessage).isEqualTo(rawMessage);
// signing
SecuritySignature signature = access.newSignerUnsafe(privateKey).sign(rawMessage, true);
boolean signatureVerified = access.newVerifierUnsafe(publicKey).verifyUnsafe(rawMessage, signature);
assertThat(signatureVerified).as("signature verified").isTrue();
-----

On the first view this might not look much simpler than plain JCA/JCE. However, by only changing a single line you can
change the encryption and key algorithms with all according settings. If you replace the third line with the following it will use RSA with a key-length of 4096:
[source,java]
-----
SecurityAccessRsa access = SecurityAccessRsa.of4096(sha256x2);
-----

You can see in the example some methods that end with `Unsafe`. Without this suffix the API is typesafe to prevent errors passing 
the wrong type of key or signature to a specific algorithm. To make the code typesafe, you can use more specific types than `PublicKey`, etc.
and remove the `Unsafe` suffix to use the type-safe methods.
If you still want to keep your code portable so that you can change the algorithms as simple as just shown, you can simply use Java10+ type
inference syntax. In the following example we use the algorithms used by BitCoin including a signature with recovery ID what is
supported neither by JCA/JCE nor by BouncyCastle out of the box.

[source,java]
-----
var access = SecurityAccessSecp256k1.ofRecoveryId(new SecurityHashConfig("SHA-256"));
var keyCreator = access.newKeyCreator();
var keyPair = keyCreator.generateKeyPair();
var publicKey = keyPair.getPublicKey();
var privateKey = keyPair.getPrivateKey();
// encryption + decryption
var rawMessage = "Secret message".getBytes(StandardCharsets.UTF_8);
var encryptor = access.newEncryptor(publicKey);
var encryptedMessage = encryptor.crypt(rawMessage, true);
var decryptor = access.newDecryptor(privateKey);
var decryptedMessage = decryptor.crypt(encryptedMessage, true);
assertThat(decryptedMessage).isEqualTo(rawMessage);
// signing
var signature = access.newSigner(privateKey).sign(rawMessage, true);
var signatureVerified = access.newVerifier(publicKey).verifyUnsafe(rawMessage, signature);
assertThat(signatureVerified).as("signature verified").isTrue();
assertThat(signature.recoverPublicKey(rawMessage)).isEqualTo(publicKey);
-----

This is all just the beginning. 
There is even much more. Dealing with JCA/JCE directly is rather complex and error-prone what easily leads to runtime
errors or security frauds and vulnerabilities. Using this library will make your life a lot more simple and safe.

== Dependency

```
  <dependency>
    <groupId>net.sf.m-m-m</groupId>
    <artifactId>mmm-security-bc</artifactId>
    <version>1.0.0</version>
  </dependency>
```